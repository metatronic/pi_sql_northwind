--NORTHWIND DATABASE – PROGRAMMING ASSIGNMENT
--1.	WRITE A PROCEDURE WHICH TAKES CATEGORY NAME AS A PARAMETER AND RETURN ALL PRODUCTS WHICH MATCH WITH THE CATEGORY NAME. IF NAME NOT EXIST PRINT MESSAGE

CREATE PROCEDURE CATEGORY_WISE_PRODUCTS(@CATEGORYNAME VARCHAR(20)) AS
BEGIN
	SELECT * FROM PRODUCTS WHERE CATEGORYID IN (SELECT CATEGORYID FROM CATEGORIES WHERE CATEGORYNAME = @CATEGORYNAME)
	IF @@ROWCOUNT = 0
	BEGIN
		PRINT 'CATEGORY DOES NOT EXIST'
	END
END

EXEC CATEGORY_WISE_PRODUCTS 'CONFECTIONS'

--SELECT * FROM CATEGORIES

--2.	TAKE COUNTRY NAME AS THE PARAMETER AND RETURN ALL CUSTOMERS FROM THAT COUNTRY

CREATE PROCEDURE CUSTOMER_FROM_COUNTRY (@COUNTRY AS VARCHAR(20)) AS
BEGIN
	SELECT * FROM CUSTOMERS C WHERE C.COUNTRY = @COUNTRY
END

EXEC CUSTOMER_FROM_COUNTRY 'UK'

--3.       WRITE INSERT, UPDATE AND DELETE PROCEDURE FOR EMPLOYEES TABLE. IF ANY STATEMENT FAIL RAISE PROPER ERROR MESSAGE
--PARAMETER : EMPLOYEEID         LASTNAME         FIRSTNAME        TITLE      TITLEOFCOURTESY           BIRTHDATE                HIREDATE            ADDRESS             CITY       REGION                POSTALCODE     COUNTRY

CREATE PROCEDURE INSERT_EMPLOYEE 
(@EMPLOYEEID INT, @LASTNAME VARCHAR(40), @FIRSTNAME VARCHAR(20), @TITLE VARCHAR(60), @TITLEOFCOURTESY VARCHAR(50), @BIRTHDAY DATETIME, @HIREDATE DATETIME, @ADDRESS VARCHAR(120), @CITY VARCHAR(30), @REGION VARCHAR(30), @POSTALCODE VARCHAR(20), @COUNTRY VARCHAR(30) )
AS
BEGIN
	BEGIN TRY
		INSERT INTO EMPLOYEES(EMPLOYEEID,LASTNAME,FIRSTNAME,TITLE,TITLEOFCOURTESY,BIRTHDATE,HIREDATE,ADDRESS,CITY,REGION,POSTALCODE,COUNTRY)
		VALUES(@EMPLOYEEID, @LASTNAME, @FIRSTNAME, @TITLE, @TITLEOFCOURTESY , @BIRTHDAY, @HIREDATE, @ADDRESS, @CITY, @REGION, @POSTALCODE, @COUNTRY)
	END TRY
	BEGIN CATCH
		THROW 50001,'VALUE NOT INSERTED',0
	END CATCH
END

CREATE PROCEDURE UPDATE_EMPLOYEE 
(@EMPLOYEEID INT, @LASTNAME VARCHAR(40), @FIRSTNAME VARCHAR(20), @TITLE VARCHAR(60), @TITLEOFCOURTESY VARCHAR(50), @BIRTHDAY DATETIME, @HIREDATE DATETIME, @ADDRESS VARCHAR(120), @CITY VARCHAR(30), @REGION VARCHAR(30), @POSTALCODE VARCHAR(20), @COUNTRY VARCHAR(30) )
AS
BEGIN
	BEGIN TRY
		UPDATE EMPLOYEES SET LASTNAME = @LASTNAME,FIRSTNAME=@FIRSTNAME,TITLE=@TITLE,TITLEOFCOURTESY=@TITLEOFCOURTESY,BIRTHDATE=@BIRTHDAY,HIREDATE=@HIREDATE,ADDRESS=@ADDRESS,CITY=@CITY,REGION=@REGION,POSTALCODE=@POSTALCODE,COUNTRY=@COUNTRY
	END TRY
	BEGIN CATCH
		THROW 50002,'VALUE NOT UPDATED',0
	END CATCH
END

CREATE PROCEDURE DELETE_EMPLOYEE (@EMPLOYEEID INT)
AS
BEGIN
	BEGIN TRY
		DELETE EMPLOYEES WHERE EMPLOYEEID = @EMPLOYEEID
	END TRY
	BEGIN CATCH
		THROW 50003,'VALUE NOT DELETED',0
	END CATCH
END
--SP_HELP EMPLOYEES

--4.       TAKE REGIONDESCRIPTION AS A PARAMETER
--PRINT REGIONDESCRIPTION,  TERRITORY DESCRIPTION, AND EMPNAME

CREATE PROCEDURE PRINT_REGION_DESCRIPTION(@REGIONDESCRIPTION VARCHAR(20)) AS
BEGIN
	DECLARE  @TERRITORYDESCRIPTION VARCHAR(20),@EMPNAME VARCHAR(20), @EMPNO INT
	DECLARE EMPCURSOR CURSOR FOR SELECT T.TERRITORYDESCRIPTION, E.FIRSTNAME FROM EMPLOYEES E JOIN EMPLOYEETERRITORIES ET ON E.EMPLOYEEID = ET.EMPLOYEEID
	JOIN TERRITORIES T ON ET.TERRITORYID = T.TERRITORYID JOIN REGION R ON T.REGIONID = R.REGIONID
	WHERE R.REGIONDESCRIPTION = @REGIONDESCRIPTION

	OPEN EMPCURSOR
	FETCH NEXT FROM EMPCURSOR INTO @TERRITORYDESCRIPTION ,@EMPNAME
	WHILE @@FETCH_STATUS = 0
	BEGIN
		PRINT @REGIONDESCRIPTION +' '+@TERRITORYDESCRIPTION +' '+@EMPNAME ;
		FETCH NEXT FROM EMPCURSOR INTO @TERRITORYDESCRIPTION ,@EMPNAME
	END
	CLOSE EMPCURSOR
	DEALLOCATE EMPCURSOR
END
EXEC PRINT_REGION_DESCRIPTION 'WESTERN'

--5.       PRODUCTS TABLE
--WRITE A PROCEDURE WHICH CHECKS UNITSINSTOCK AND UNITSONORDER
--DISPLAY ALL PRODUCTS DETAILS (PRODUCTNAME, UNITPRICE, UNITSINSTOCK, UNITSONORDER, DIFFERENCE )  where UNITSONORDER is more then UNITSINSTOCK

CREATE PROCEDURE UNITS_STOCK_ORDER AS
BEGIN
	SELECT PRODUCTNAME, UNITPRICE, UNITSINSTOCK, UNITSONORDER, UNITSONORDER - UNITSINSTOCK AS [DIFFERENCE] FROM PRODUCTS
	WHERE UNITSONORDER > UNITSINSTOCK
END

EXEC UNITS_STOCK_ORDER

--6.       ORDER DETAILS TABLE
--TAKE ORDERID AS PARAMETER
--FOR THE ORDERID PRINT PRODUCTNAME, UNITPRICE, QUANTITY, DISCOUNT, TOTAL I.E UNITPRICE * QUNATITY, DISCOUNTAMOUNT, FINAL PRICE I.E. TOTAL – DISCOUNT AMOUNT

SELECT * FROM [ORDER DETAILS]

CREATE PROCEDURE ORDER_DETAILS_FROM_ID (@ORDERID INT) AS
BEGIN
	SELECT P.PRODUCTNAME, OD.UNITPRICE, OD.QUANTITY, OD.DISCOUNT, OD.UNITPRICE * OD.QUANTITY TOTAL, DISCOUNT, (OD.UNITPRICE * OD.QUANTITY) - DISCOUNT AS [FINAL PRICE]
	FROM [ORDER DETAILS] OD JOIN PRODUCTS P ON OD.PRODUCTID = P.PRODUCTID WHERE ORDERID = @ORDERID
END

EXEC ORDER_DETAILS_FROM_ID 10248


--7.       WRITE A PROCEDURE WHICH INSERT IN PRODUCTTABLE
--PARAMETER FOR PROCEDURE PRODUCTNAME, UNITPRICE AND CATEGORYNAME
--CHECK IF CATEGORYNAME EXIST THEN ADD PRODUCTS WITH EXISTING CATEGORYID
--IF CATEGORYNAME DOES NOT EXIST FIRST INSERT IN CATEGORY TABLE
--READ CATEGORYID WHICH IS IDENTITY FIELD
--AND INSERT NEW INSERTED ID IN PRODUCT TABLE AS CATEGORYID

CREATE PROC INSERT_PRODUCT(@PRODUCTNAME VARCHAR(20), @UNITPRICE NUMERIC(10,2), @CATEGORYNAME VARCHAR(20)) AS
BEGIN
	DECLARE @ID INT
	IF EXISTS (SELECT * FROM CATEGORIES WHERE CATEGORYNAME = @CATEGORYNAME) 
	BEGIN
		INSERT INTO PRODUCTS(PRODUCTNAME,UNITPRICE,CATEGORYID) VALUES(@PRODUCTNAME,@UNITPRICE,(SELECT CATEGORYID FROM CATEGORIES WHERE CATEGORYNAME = @CATEGORYNAME))
	END
	ELSE
	BEGIN
		INSERT INTO CATEGORIES(CATEGORYNAME) VALUES (@CATEGORYNAME)
		SET @ID = SCOPE_IDENTITY()
		INSERT INTO PRODUCTS(PRODUCTNAME,UNITPRICE,CATEGORYID) VALUES(@PRODUCTNAME,@UNITPRICE,@ID)
	END
END

SELECT * FROM PRODUCTS 
EXEC INSERT_PRODUCT 'BREAD', 12, 'PRODUCE'

--8.       ORDERS TABLE
--TAKE YEAR AS PARAMETER TO PROCEDURE
--PRINT IN EACH QUARTER HOW MANY ORDERS BOOKED, 
--EXAMPLE IN Q-1 100
--                        Q-2 150 ….
--IF YEAR NOT EXIST PRINT ERROR MESSAGE

SELECT * FROM ORDERS

CREATE PROC PRINT_QTR(@YEAR INT) AS
BEGIN
	DECLARE @Q1  INT, @Q2  INT,@Q3  INT,@Q4  INT
	SELECT @Q1 = COUNT(ORDERID) FROM ORDERS WHERE DATEPART(YYYY,ORDERDATE) = @YEAR AND DATEPART(MM,ORDERDATE) BETWEEN 1 AND 3
	SELECT @Q2 = COUNT(ORDERID) FROM ORDERS WHERE DATEPART(YYYY,ORDERDATE) = @YEAR AND DATEPART(MM,ORDERDATE) BETWEEN 4 AND 6
	SELECT @Q3 = COUNT(ORDERID) FROM ORDERS WHERE DATEPART(YYYY,ORDERDATE) = @YEAR AND DATEPART(MM,ORDERDATE) BETWEEN 7 AND 9
	SELECT @Q4 = COUNT(ORDERID) FROM ORDERS WHERE DATEPART(YYYY,ORDERDATE) = @YEAR AND DATEPART(MM,ORDERDATE) BETWEEN 10 AND 12
	PRINT 'Q-1 '+CONVERT(VARCHAR,@Q1)
	PRINT 'Q-2 '+CONVERT(VARCHAR,@Q2)
	PRINT 'Q-3 '+CONVERT(VARCHAR,@Q3)
	PRINT 'Q-4 '+CONVERT(VARCHAR,@Q4)
END

EXEC PRINT_QTR 1996


--9.       TABLE ORDERS AND ORDER DETAILS – OUT PARAMETER
--TAKE YEAR AND MONTH AS PARAMETER AND RETURN
--TOTAL REVENUE GENERATED SUM(UNITPRICE * QTY – DISCOUNT)
CREATE PROC GET_TOTAL_REVENUE(@YEAR INT, @MONTH INT, @TOTAL_REV NUMERIC(10,2) OUT) AS
BEGIN
	SELECT @TOTAL_REV = SUM(OD.UNITPRICE*OD.QUANTITY - OD.DISCOUNT) FROM [ORDER DETAILS] OD
	WHERE OD.ORDERID IN (SELECT O.ORDERID FROM ORDERS O WHERE O.ORDERID = OD.ORDERID AND DATEPART(YYYY,O.ORDERDATE) = @YEAR AND DATEPART(MM,O.ORDERDATE) = @MONTH)
END

DECLARE @REV NUMERIC(10,2)
EXEC GET_TOTAL_REVENUE 1996 ,9 , @REV OUT
PRINT @REV


--10.   FOR EACH EMPLOYEE PRINT EMPLOYEE FULL NAME, BIRTHDATE, HIREDATE, AGE (IN YEARS) AT THE TIME OF HIRING, RETIREMENT DATE. (60 YEARS)
--SELECT * FROM EMPLOYEES
CREATE PROCEDURE PRINT_EMP_HIRE_RETIREMENT AS
BEGIN
	DECLARE @EMPNO INT, @NAME VARCHAR(20), @BIRTHDAY DATETIME, @HIREDATE DATETIME, @AGE_AT_HIRE INT, @RETIRE_DATE DATETIME
	SELECT @EMPNO = MIN(E.EMPLOYEEID) FROM EMPLOYEES E
	WHILE @EMPNO IS NOT NULL
	BEGIN
		SELECT @NAME=E.FIRSTNAME+' '+E.LASTNAME,
			@BIRTHDAY = E.BIRTHDATE,
			@HIREDATE = E.HIREDATE,
			@AGE_AT_HIRE = DATEDIFF(YEAR,E.BIRTHDATE,E.HIREDATE),
			@RETIRE_DATE = DATEADD(YEAR,60,E.HIREDATE)
			FROM EMPLOYEES E WHERE E.EMPLOYEEID = @EMPNO
		PRINT @NAME + ' ' + CONVERT(VARCHAR,@BIRTHDAY,5) + ' ' + CONVERT(VARCHAR,@HIREDATE,5) + ' ' + CONVERT(VARCHAR,@AGE_AT_HIRE) + ' ' + CONVERT(VARCHAR,@RETIRE_DATE,5)
		SELECT @EMPNO = MIN(E.EMPLOYEEID) FROM EMPLOYEES E WHERE E.EMPLOYEEID > @EMPNO
	END
END
EXEC PRINT_EMP_HIRE_RETIREMENT